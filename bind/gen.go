// Copyright 2019 The go-python Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bind

import (
	"go/token"
	"path/filepath"
)

// this version uses pybindgen and a generated .go file to do the binding

// for all preambles: 1 = name of package, 2 = full import path of package

const (
	pybGoPreamble = `/*
	cgo stubs for package %[2]s.
	gopy gen -api=pybind %[2]s

	File is generated by gopy gen. Do not edit.
*/

package main

// #cgo pkg-config: %[3]s
// #define Py_LIMITED_API
// #include <Python.h>
import "C"
import (
	"fmt"
	"strconv"
	"strings"
	"sync"
	
	"%[2]s"
)

func main() {}

// --- variable handles: all pointers managed via handles ---

type varHandler struct {
	ctr  int64
	vars map[string]interface{}
	m    sync.RWMutex
}

var varHand varHandler

func (vh *varHandler) register(typnm string, ifc interface{}) *C.char {
	vh.m.Lock()
	defer vh.m.Unlock()
	if vh.vars == nil {
		vh.vars = make(map[string]interface{})
	}
	hc := vh.ctr
	vh.ctr++
	rnm := typnm + "_" + strconv.FormatInt(hc, 10)
	vh.vars[rnm] = ifc
	return C.CString(rnm)
}

// varFmHandle gets variable from handle string -- reports error to python but does not return it
// for use in inline calls
func (vh *varHandler) varFmHandle(h *C.char, typnm string) interface{} {
	v, _ := vh.varFmHandleTry(h, typnm)
	return v
}

// Try version returns the error explicitly, for use when error can be processed
func (vh *varHandler) varFmHandleTry(h *C.char, typnm string) (interface{}, error) {
	vh.m.RLock()
	defer vh.m.RUnlock()
	hs := C.GoString(h)
	if !strings.HasPrefix(hs, typnm) {
		err := fmt.Errorf("gopy: variable handle is not the correct type, should be: " + typnm + " is: " +  hs)
		C.PyErr_SetString(C.PyExc_TypeError, C.CString(err.Error()))
		return nil, err
	}
	v, has := vh.vars[hs]
	if !has {
		err := fmt.Errorf("gopy: variable handle not registered: " +  hs)
		C.PyErr_SetString(C.PyExc_TypeError, C.CString(err.Error()))
		return nil, err
	}
	return v, nil
}

// --- generated code for package: %[1]s below: ---

`

	PyBuildPreamble = `# python build stubs for package %[2]s
# File is generated by gopy gen. Do not edit.
# gopy gen %[2]s

from pybindgen import retval, param, Module
import sys

mod = Module('_%[1]s')
mod.add_include('"%[1]s_go.h"')
`

	PyWrapPreamble = `# python wrapper for package %[2]s
# This is what you import to use the package.
# File is generated by gopy gen. Do not edit.
# gopy gen %[2]s


import _%[1]s

`

	MakefileTemplate = `# Makefile for python interface to Go package %[2]s.
# File is generated by gopy gen. Do not edit.
# gopy gen %[2]s

GOCMD=go
GOBUILD=$(GOCMD) build
PYTHON=%[3]s
PYTHON_CFG=$(PYTHON)-config
GCC=gcc

# get the flags used to build python:
CFLAGS = $(shell $(PYTHON_CFG) --cflags)
LDFLAGS = $(shell $(PYTHON_CFG) --ldflags)

all: build

build:
	# this will otherwise be built during go build and may be out of date
	- rm %[1]s.c
	# generate %[1]s_go.so from %[1]s.go -- the cgo wrappers to go functions
	$(GOBUILD) -buildmode=c-shared -ldflags="-s -w" -o %[1]s_go.so %[1]s.go
	# use pybindgen to build the %[1]s.c file which are the CPython wrappers to cgo wrappers..
	# note: pip install pybindgen to get pybindgen if this fails
	$(PYTHON) build.py
	# build the _%[1]s.so library that contains the cgo and CPython wrappers
	# generated %[1]s.py python wrapper imports this c-code package
	$(GCC) %[1]s.c -dynamiclib %[1]s_go.so -o _%[1]s.so $(CFLAGS) $(LDFLAGS)
`
)

type pybindGen struct {
	gofile   *printer
	pybuild  *printer
	pywrap   *printer
	makefile *printer

	fset *token.FileSet
	pkg  *Package
	err  ErrorList

	vm   string // python interpreter
	lang int    // c-python api version (2,3)
}

func (g *pybindGen) gen() error {
	g.genGoPreamble()
	g.genPyBuildPreamble()
	g.genPyWrapPreamble()
	g.genMakefile()
	g.genAll()
	n := g.pkg.pkg.Name()
	g.pybuild.Printf("\nmod.generate(open('%v.c', 'w'))\n", n)
	return nil
}

func (g *pybindGen) genGoPreamble() {
	n := g.pkg.pkg.Name()
	pkgimport := g.pkg.pkg.Path()
	pypath, pyonly := filepath.Split(g.vm)
	pyroot, _ := filepath.Split(filepath.Clean(pypath))
	libcfg := filepath.Join(filepath.Join(filepath.Join(pyroot, "lib"), "pkgconfig"), pyonly+".pc")
	g.gofile.Printf(pybGoPreamble, n, pkgimport, libcfg)
}

func (g *pybindGen) genPyBuildPreamble() {
	n := g.pkg.pkg.Name()
	pkgimport := g.pkg.pkg.Path()
	g.pybuild.Printf(PyBuildPreamble, n, pkgimport)
}

func (g *pybindGen) genPyWrapPreamble() {
	n := g.pkg.pkg.Name()
	pkgimport := g.pkg.pkg.Path()
	pkgDoc := g.pkg.doc.Doc
	if pkgDoc != "" {
		g.pywrap.Printf(PyWrapPreamble, n, pkgimport, `"""`+pkgDoc+`"""`)
	} else {
		g.pywrap.Printf(PyWrapPreamble, n, pkgimport, "")
	}
}

func (g *pybindGen) genMakefile() {
	n := g.pkg.pkg.Name()
	pkgimport := g.pkg.pkg.Path()
	g.makefile.Printf(MakefileTemplate, n, pkgimport, g.vm)
}

func (g *pybindGen) genAll() {

	// first, process slices, arrays
	// if false {
	names := g.pkg.syms.names()
	for _, n := range names {
		sym := g.pkg.syms.sym(n)
		if !sym.isType() {
			continue
		}
		g.genType(sym)
	}

	for _, s := range g.pkg.structs {
		g.genStruct(s)
	}

	for _, s := range g.pkg.structs {
		for _, ctor := range s.ctors {
			g.genFunc(ctor)
		}
	}

	for _, f := range g.pkg.funcs {
		g.genFunc(f)
	}

	// for _, c := range g.pkg.consts {
	// 	g.genGoConst(c)
	// }
	//
	// for _, v := range g.pkg.vars {
	// 	g.genGoVar(v)
	// }
}

/*
func (g *pybindGen) genConst(c Const) {
	g.genGetFunc(c.f)
}

func (g *pybindGen) genVar(v Var) {
	id := g.pkg.Name() + "_" + v.Name()
	get := "returns " + g.pkg.Name() + "." + v.Name()
	set := "sets " + g.pkg.Name() + "." + v.Name()
	if v.doc != "" {
		// if the Go variable had some documentation attached,
		// put it there as well.
		get += "\n\n" + v.doc
		set += "\n\n" + v.doc
	}
	doc := v.doc
	{
		res := []*Var{newVar(g.pkg, v.GoType(), "ret", v.Name(), doc)}
		sig := newSignature(g.pkg, nil, nil, res)
		fget := Func{
			pkg:  g.pkg,
			sig:  sig,
			typ:  nil,
			name: v.Name(),
			id:   id + "_get",
			doc:  get,
			ret:  v.GoType(),
			err:  false,
		}
		g.genGetFunc(fget)
	}
	{
		params := []*Var{newVar(g.pkg, v.GoType(), "arg", v.Name(), doc)}
		sig := newSignature(g.pkg, nil, params, nil)
		fset := Func{
			pkg:  g.pkg,
			sig:  sig,
			typ:  nil,
			name: v.Name(),
			id:   id + "_set",
			doc:  set,
			ret:  nil,
			err:  false,
		}
		g.genSetFunc(fset)
	}
}

func (g *pybindGen) genGoConst(c Const) {
	g.genGoFunc(c.f)
}

func (g *pybindGen) genGoVar(v Var) {
	id := g.pkg.Name() + "_" + v.Name()
	doc := v.doc
	{
		res := []*Var{newVar(g.pkg, v.GoType(), "ret", v.Name(), doc)}
		sig := newSignature(g.pkg, nil, nil, res)
		fget := Func{
			pkg:  g.pkg,
			sig:  sig,
			typ:  nil,
			name: v.Name(),
			id:   id + "_get",
			doc:  "returns " + g.pkg.Name() + "." + v.Name(),
			ret:  v.GoType(),
			err:  false,
		}
		g.genGoFunc(fget)
	}
	{
		params := []*Var{newVar(g.pkg, v.GoType(), "arg", v.Name(), doc)}
		sig := newSignature(g.pkg, nil, params, nil)
		fset := Func{
			pkg:  g.pkg,
			sig:  sig,
			typ:  nil,
			name: v.Name(),
			id:   id + "_set",
			doc:  "sets " + g.pkg.Name() + "." + v.Name(),
			ret:  nil,
			err:  false,
		}
		g.genGoFunc(fset)
	}
}
*/

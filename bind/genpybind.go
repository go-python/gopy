// Copyright 2019 The go-python Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bind

import (
	"fmt"
	"go/token"
)

// this version uses pybindgen and a generated .go file to do the binding

const (
	pybGoPreamble = `/*
	cgo stubs for package %[1]s.
	gopy gen -api=pybind %[1]s

	File is generated by gopy gen. Do not edit.
*/

package main

// #cgo pkg-config: /usr/local/opt/python3/lib/pkgconfig/python-3.6.pc
// #define Py_LIMITED_API
// #include <Python.h>
import "C"
import (
	"fmt"
	"strconv"
	"strings"
	"sync"
	
	%[2]s
)

func main() {}

// --- variable handles: all pointers managed via handles ---

type varHandler struct {
	ctr  int64
	vars map[string]interface{}
	m    sync.RWMutex
}

var varHand varHandler

func (vh *varHandler) register(typnm string, ifc interface{}) *C.char {
	vh.m.Lock()
	defer vh.m.Unlock()
	if vh.vars == nil {
		vh.vars = make(map[string]interface{})
	}
	hc := vh.ctr
	vh.ctr++
	rnm := typnm + "_" + strconv.FormatInt(hc, 10)
	vh.vars[rnm] = ifc
	return C.CString(rnm)
}

// varFmHandle gets variable from handle string -- reports error to python but does not return it
// for use in inline calls
func (vh *varHandler) varFmHandle(h *C.char, typnm string) interface{} {
	v, _ := vh.varFmHandleTry(h, typnm)
	return v
}

// Try version returns the error explicitly, for use when error can be processed
func (vh *varHandler) varFmHandleTry(h *C.char, typnm string) (interface{}, error) {
	vh.m.RLock()
	defer vh.m.RUnlock()
	hs := C.GoString(h)
	if !strings.HasPrefix(hs, typnm) {
		err := fmt.Errorf("gopy: variable handle is not the correct type, should be: " + typnm + " is: " +  hs)
		C.PyErr_SetString(C.PyExc_TypeError, C.CString(err.Error()))
		return nil, err
	}
	v, has := vh.vars[hs]
	if !has {
		err := fmt.Errorf("gopy: variable handle not registered: " +  hs)
		C.PyErr_SetString(C.PyExc_TypeError, C.CString(err.Error()))
		return nil, err
	}
	return v, nil
}

// --- generated code for package: %[1]s below: ---

`

	pybPyPreamble = `# python build stubs for package %[1]s.
# gopy gen -api=pybind %[1]s

# File is generated by gopy gen. Do not edit.

from pybindgen import retval, param, Module
import sys

mod = Module('%[1]s')
mod.add_include('"%[1]s_go.h"')
`
)

type pybindGen struct {
	gofile   *printer
	pyfile   *printer
	makefile *printer

	fset *token.FileSet
	pkg  *Package
	err  ErrorList

	vm   string // python interpreter
	lang int    // c-python api version (2,3)
}

func (g *pybindGen) gen() error {
	g.genGoPreamble()
	g.genPyPreamble()
	g.genAll()
	n := g.pkg.pkg.Name()
	g.pyfile.Printf("\nmod.generate(open('%v.c', 'w'))\n", n)
	return nil
}

func (g *pybindGen) genGoPreamble() {
	n := g.pkg.pkg.Name()
	pkgimport := fmt.Sprintf("%q", g.pkg.pkg.Path())
	g.gofile.Printf(pybGoPreamble, n, pkgimport)
}

func (g *pybindGen) genPyPreamble() {
	n := g.pkg.pkg.Name()
	pkgDoc := g.pkg.doc.Doc
	if pkgDoc != "" {
		g.pyfile.Printf(pybPyPreamble, n, `"""`+pkgDoc+`"""`)
	} else {
		g.pyfile.Printf(pybPyPreamble, n, "")
	}
}

func (g *pybindGen) genAll() {

	// first, process slices, arrays
	// if false {
	names := g.pkg.syms.names()
	for _, n := range names {
		sym := g.pkg.syms.sym(n)
		if !sym.isType() {
			continue
		}
		g.genType(sym)
	}

	// Register struct type defintions
	// for _, s := range g.pkg.structs {
	// 	g.genGoStruct(s)
	// }

	for _, s := range g.pkg.structs {
		for _, ctor := range s.ctors {
			g.genFunc(ctor)
		}
	}

	for _, s := range g.pkg.structs {
		for _, m := range s.meths {
			g.genMethod(s, m)
		}

		// typ := s.Struct()
		// for i := 0; i < typ.NumFields(); i++ {
		// 	f := typ.Field(i)
		// 	if !f.Exported() {
		// 		continue
		// 	}
		// 	g.genGoStructMemberGetter(s, i, f)
		// 	g.genGoStructMemberSetter(s, i, f)
		// }
		//
		// g.genGoStructTPStr(s)
	}

	for _, f := range g.pkg.funcs {
		g.genFunc(f)
	}

	// for _, c := range g.pkg.consts {
	// 	g.genGoConst(c)
	// }
	//
	// for _, v := range g.pkg.vars {
	// 	g.genGoVar(v)
	// }
}

/*
func (g *pybindGen) genConst(c Const) {
	g.genGetFunc(c.f)
}

func (g *pybindGen) genVar(v Var) {
	id := g.pkg.Name() + "_" + v.Name()
	get := "returns " + g.pkg.Name() + "." + v.Name()
	set := "sets " + g.pkg.Name() + "." + v.Name()
	if v.doc != "" {
		// if the Go variable had some documentation attached,
		// put it there as well.
		get += "\n\n" + v.doc
		set += "\n\n" + v.doc
	}
	doc := v.doc
	{
		res := []*Var{newVar(g.pkg, v.GoType(), "ret", v.Name(), doc)}
		sig := newSignature(g.pkg, nil, nil, res)
		fget := Func{
			pkg:  g.pkg,
			sig:  sig,
			typ:  nil,
			name: v.Name(),
			id:   id + "_get",
			doc:  get,
			ret:  v.GoType(),
			err:  false,
		}
		g.genGetFunc(fget)
	}
	{
		params := []*Var{newVar(g.pkg, v.GoType(), "arg", v.Name(), doc)}
		sig := newSignature(g.pkg, nil, params, nil)
		fset := Func{
			pkg:  g.pkg,
			sig:  sig,
			typ:  nil,
			name: v.Name(),
			id:   id + "_set",
			doc:  set,
			ret:  nil,
			err:  false,
		}
		g.genSetFunc(fset)
	}
}

func (g *pybindGen) genGoConst(c Const) {
	g.genGoFunc(c.f)
}

func (g *pybindGen) genGoVar(v Var) {
	id := g.pkg.Name() + "_" + v.Name()
	doc := v.doc
	{
		res := []*Var{newVar(g.pkg, v.GoType(), "ret", v.Name(), doc)}
		sig := newSignature(g.pkg, nil, nil, res)
		fget := Func{
			pkg:  g.pkg,
			sig:  sig,
			typ:  nil,
			name: v.Name(),
			id:   id + "_get",
			doc:  "returns " + g.pkg.Name() + "." + v.Name(),
			ret:  v.GoType(),
			err:  false,
		}
		g.genGoFunc(fget)
	}
	{
		params := []*Var{newVar(g.pkg, v.GoType(), "arg", v.Name(), doc)}
		sig := newSignature(g.pkg, nil, params, nil)
		fset := Func{
			pkg:  g.pkg,
			sig:  sig,
			typ:  nil,
			name: v.Name(),
			id:   id + "_set",
			doc:  "sets " + g.pkg.Name() + "." + v.Name(),
			ret:  nil,
			err:  false,
		}
		g.genGoFunc(fset)
	}
}
*/
